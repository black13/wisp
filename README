This is intended to be a simple lisp implementation as my own little
experiment. It's a dynamically typed lisp-1 (functions share a
namespace with variables). Memmory is managed by reference counting.

There are still lots of checks missing. Some useful types are
implemented yet, like arrays and hashtables. However, the code's here
and it's pretty easy to dig in. So if you're interested dive in and
write it! :-)

At the same time, a lot could still change, cleaning up the codebase.

I don't plan on sticking readline or something on top of the
interactive prompt. I suggest you use rlwrap with it.

It would also be useful to add this to your .emacs file,

(add-to-list 'auto-mode-alist '(".wisp\\'" . lisp-interaction-mode))

== Contributing ==

All functions and macros should be in lisp form when possible. For
now, all of these are going into core.wisp.

For functions that need C access, these are currently being placed in
lisp.c. In the future, if this file gets large it will be broken up.

When I remember to, I run GNU indent on all the code with just the
-npsl flag. If you do this, your code will match the style. Compiled
code should give no warnings or errors and should conform to C99.

I've put some stuff I want to get done in the TODO list.

== Getting started with internals ==

The object_t struct defined in object.h is all the lisp objects. Cons
cells, integers, etc. It has a type field, which matches the type_t
enumeration (also defined there) indicating the object type, and a val
void pointer pointing to the object data itself.

Almost all of the convenient object creation functions are defined
here, prefixed with c_. Use these to make objects.

Symbols are interned, so they act like singletons. A given symbol has
only one instance of itself at any time. The c_sym() function will
enforce this.

Accessing objects stored in symbols can be done with the SET and GET
macros.

The nil and t symbols are already interned and are made available as
the global variables T and NIL. Object pointers, including those in
cons cells, should initialize/default to NIL rather than NULL. That
way a NULL pointer will never be dereferenced.

== Writing CFUNCs ==

CFUNCs are C functions that have the following declaration.

object_t *function (object_t *lst);

The single argument will be a cons cell object containing all your
arguments as a list. For your convenience in accessing this structure
there are a number of macros available, defined in the various header
files: CAR, CDR, OINT, OFLOAT, OSTR

Look at the existing functions for example of what to do right now.

The function eval() and eval_body() are available fir further
evaluation of the structure. This is more useful in special forms than
anything else.

Error handling works by an exception-like system. If there was an
error, the error symbol is returned, err_symbol. Any time a lisp-space
function is called (like all the eval functions), you must immediately
check the return for the error symbol. If it is, clean up and return
the error symbol too. The CHECK macro is available for when no cleanup
is needed.

To throw an error, set err_thrown to the object you want to throw;
generally it will be a symbol. Also set err_attach to the object you
want to attach at the error message. This can be a string or symbol or
whatever. The THROW macro makes this easier.

The top_eval function is the final error handler, which prints out the
error message. It should only be called by the originating
evaluator. The parser uses this, for example.

Once the function is defined, you can install it in lisp_init() with,

SET (c_sym ("function"), c_cfunc (&function));

If it's a special form you will need to adjust that to
c_special(). Like macros, special forms don't have their arguments
evaluated first.

== Working with reference counting ==

Object returners are responsible for increasing the reference
counter. The UPREF macro is provided for this. If you call a function
that returns an object, treat it like object creation, so
obj_destroy() must be called on it before returning. Macros like CAR
and CDR which "return" objects do not count as object creation.

Observe that when we create an object and return it, we have to both
increment (UPREF()) and decrement (obj_destroy()) it, which cancels
out. This way you can return created objects directly without further
action.

If you store a reference to an argument, you need to increase the
reference counter for that object. The SET macro does this for
you. Otherwise arguments don't require any special handling.

A somewhat exception to this is c_cons. It does not increase the
reference counter of the things you pass it. This is because it's
often directly passed the output of functions. This is a convenience
measure. So when passing objects to c_cons that are not being created
(not returned from a function), you need to use UPREF on them.

Because all symbol are interned, they are not destroyed, so if you
know you are dealing with interned symbols you don't need to worry
about reference counts. This counts for the special NIL and T symbols
too.
